using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using MvcTherapy.Data;
using MvcTherapy.Models;

namespace MvcTherapy.Controllers
{
    public class PatientsController : Controller
    {
        private readonly MvcTherapyContext _context;

        // dependency injection to automatically provide an instance of Entity Framework database context when controller is created
        public PatientsController(MvcTherapyContext context)
        {
            _context = context; // storing the injected context in the _context field to use it in controller actions to access the database
        }

        // GET: All Patients or Filter
        public async Task<IActionResult> Index(string searchString)
        {
            if (_context.Patient == null)
            {
                return Problem("Entity set 'MvcTherapyContext.Patient' is null.");
            }

            var patientsQuery = _context.Patient
                .Include(p => p.Ratings) // Include Ratings. Related data is not automatically loaded with EF Core (BUG)
                .OrderBy(p => p.Appointment) // Sorts by most recent appointment first
                .AsQueryable(); // Allows filtering 

            if (!string.IsNullOrEmpty(searchString))
            {
                patientsQuery = patientsQuery
                    .Where(p => p.Name!.ToUpper().Contains(searchString.ToUpper())); // filter names by search term
            }
            // Executes the LINQ query against the database asynchronously and stores the result in the patients list
            var patients = await patientsQuery.ToListAsync();
            return View(patients); // passes filtered list to Razor View for display
        }


        // GET: Patients/Details/5
        // get a patient object, and pass the model to the view.
        public async Task<IActionResult> Details(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var patient = await _context.Patient
                .Include(p => p.Ratings) // Include Ratings. Related data is not automatically loaded with EF Core (BUG)
                .FirstOrDefaultAsync(m => m.Id == id); // Find patient with the ID, FirstOrDefault needed for relationships like Includes()

            if (patient == null)
            {
                return NotFound();
            }

            // Sort ratings by DateRecorded to keep chart and tooltip in sync
            var sortedRatings = patient.Ratings
                .OrderBy(r => r.DateRecorded)
                .ToList();
            
            // lists of ratings, dates, and notes from database (for chart)
            var ratingData = sortedRatings.Select(r => r.Rating).ToList();
            var labels = sortedRatings.Select(r => r.DateRecorded.ToString("MMM dd")).ToList();
            var notes = sortedRatings.Select(r => r.Notes ?? "").ToList();

            // line chart using JavaScript. Razor canâ€™t directly interact with JS, send separate pieces of data the JS chart will use (BUG)
            ViewData["RatingData"] = ratingData;
            ViewData["Labels"] = labels;
            ViewData["Notes"] = notes;

            return View(patient); // pass patient object to view
        }


        // GET: Patients/Create
        // Modifying data in an HTTP GET method is a security risk
        public IActionResult Create()
        {
            // show new patient view (no data)
            return View();
        }


        // POST: Patients/Create
        [HttpPost]
        // validates the hidden XSRF token generated by the antiforgery token generator in the Form Tag Helper
        [ValidateAntiForgeryToken]
        // model binding system takes the posted form values and creates a Patient object that's passed as the patient parameter, protects from overposting attacks by binding input fields
        public async Task<IActionResult> Create([Bind("Id,Name,Appointment,Goals,Ratings")] Patient patient)
        {
            if (ModelState.IsValid)
            {
                _context.Add(patient); // add new patient to context
                await _context.SaveChangesAsync(); // save changes to database
                return RedirectToAction(nameof(Index)); // redirect to index page, nameof for maintainability with renaming
            }
            // if invalid input, stay on create page with input data
            return View(patient);
        }


        public async Task<IActionResult> LoadEditForm(int id)
        {
            // find patient by id given in URL
            var patient = await _context.Patient.FindAsync(id); // FindAsync only works for ids
            if (patient == null)
                return NotFound();

            // pass patient object to form so it can be pre-filled with data
            return PartialView("Edit", patient);
        }


        [HttpPost]
        // validates the hidden XSRF token generated by the antiforgery token generator in the Form Tag Helper
        [ValidateAntiForgeryToken]
        // [FromBody] tells ASP.NET Core's model binding system to read the value of the patient parameter from the body of the HTTP request.
        public async Task<IActionResult> Edit(int id, [FromBody] Patient patient)
        {
            if (id != patient.Id) // make sure id in URL matches id in patient body
                return BadRequest();

            if (!ModelState.IsValid)
                return BadRequest(ModelState);

            // find if patient exists by id given
            var existing = await _context.Patient.FindAsync(id);
            if (existing == null)
                return NotFound();

            // replace existing data with the edited data
            existing.Name = patient.Name;
            existing.Appointment = patient.Appointment;
            existing.Goals = patient.Goals;

            await _context.SaveChangesAsync(); // save changes to database

            return Json(new // send JSON data to page so that AJAX (js) can update page dynamically 
            {
                name = existing.Name,
                appointment = existing.Appointment,
                goals = existing.Goals
            });
        }


        // GET: Patients/Delete/5
        public async Task<IActionResult> Delete(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            // find if patient exists by id given through URL
            var patient = await _context.Patient
                .FindAsync(id);
            if (patient == null)
            {
                return NotFound();
            }

            return View(patient); // show Delete View with patient's data
        }


        // POST: Patients/Delete/5
        [HttpPost, ActionName("Delete")] // Even though this method has a different name (DeleteConfirmed) treat it as if it were called Delete when routing
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            var patient = await _context.Patient.FindAsync(id);
            if (patient != null)
            {
                _context.Patient.Remove(patient); // remove patient from context
            }

            await _context.SaveChangesAsync(); // make changes permanent in database
            return RedirectToAction(nameof(Index)); // redirect to index page, nameof for maintainability with renaming
        }
    }
}
